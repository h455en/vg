<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Events Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --indigo: #4f46e5;
            --muted: #6b7280;
            --bg: #f8fafc;
            --card: #ffffff;
            --sidebar-bg: #eef2ff;
            --accent: #eef2ff;
        }

        html,
        body {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        body {
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
            font-size: 16px;
            background: var(--bg);
            margin: 0;
            color: #0f172a;
        }

        /* Top nav */
        header.app-header {
            background: var(--card);
            border-bottom: 1px solid #e6edf3;
            position: sticky;
            top: 0;
            z-index: 40;
        }

        .topbar {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 12px 16px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .brand h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #0b1220;
        }

        /* --- MENU STYLE --- */
        nav.topnav {
            display: flex;
            gap: 0px;
            align-items: center;
            border: 1px solid #e6edf3;
            border-radius: 8px;
            padding: 0;
            background: #f8fafc;
            flex-shrink: 0;
        }

        .topnav button {
            background: transparent;
            border: none;
            padding: 8px 12px;
            border-radius: 0;
            cursor: pointer;
            color: #1f2937;
            font-weight: 500;
            transition: background 0.15s ease;
            font-size: 14px;
            white-space: nowrap;
            /* Prevent wrap in menu items */
        }

        .topnav button:hover {
            background: #eef2ff;
            color: var(--indigo);
        }

        /* Apply rounded corners to first and last buttons */
        .topnav button:first-child {
            border-radius: 8px 0 0 8px;
        }

        .topnav button:last-child {
            border-radius: 0 8px 8px 0;
        }

        .topnav .active {
            color: white;
            background: var(--indigo);
            font-weight: 600;
        }

        .topnav .active:hover {
            background: var(--indigo);
            color: white;
        }

        /* progress line */
        #progress-wrap {
            height: 4px;
            width: 100%;
            background: transparent;
            overflow: hidden;
            display: block;
        }

        #progress {
            height: 4px;
            width: 0%;
            transition: width 260ms linear;
            border-radius: 2px;
        }

        /* Main layout - Sidebar removed, so no need for complex row/column layouts */
        .layout {
            flex: 1;
            display: block;
            max-width: 1200px;
            margin: 18px auto;
            padding: 0 16px;
        }

        /* Content card */
        .card {
            flex: 1;
            background: var(--card);
            border-radius: 12px;
            padding: 18px;
            box-shadow: 0 6px 20px rgba(12, 18, 35, 0.04);
            min-width: 0;
        }

        /* month tabs */
        .month-tabs {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 6px;
            margin-bottom: 12px;
        }

        .month-tab {
            padding: 8px 12px;
            border-radius: 999px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            flex-shrink: 0;
            /* Important for horizontal scroll */
        }

        .month-tab:hover {
            transform: translateY(-2px);
            transition: transform .14s ease;
            opacity: 0.95;
        }

        /* events */
        .day-card {
            border-radius: 12px;
            border: 1px solid #e0e7ff;
            margin-bottom: 16px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(12, 18, 35, 0.05);
        }

        .day-head {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 12px 16px;
            align-items: center;
            cursor: pointer;
        }

        .day-head strong {
            font-size: 18px;
            font-weight: 700;
        }

        .day-content {
            padding: 12px;
            display: block;
            border-top: 1px solid rgba(224, 231, 255, 0.5);
        }

        /* Event Row Styling */
        .event-row {
            background: white;
            border: 1px solid #eef2f8;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            gap: 10px;
            align-items: flex-start;
            box-shadow: 0 2px 5px rgba(12, 18, 35, 0.02);
        }

        .event-row button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        /* Title: Made bigger (18px) and bolder (700) */
        .event-row .title {
            font-weight: 700;
            color: #0b1220;
            text-decoration: none;
            font-size: 18px;
            display: block;
            line-height: 1.3;
        }

        /* Meta/Address: Made smaller (14px) and normal weight */
        .event-row .meta {
            color: var(--muted);
            font-size: 14px;
            font-weight: 500;
            line-height: 1.3;
            margin-top: 4px;
        }

        /* Map Section Styling */
        #map-container {
            height: 60vh;
            min-height: 350px;
            background: #f8fafc;
            border-radius: 10px;
            border: 1px solid #eef2f8;
            transition: opacity 0.3s ease;
        }

        /* config list */
        .config-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            background: #f8fafc;
            border: 1px solid #eef2f8;
        }

        .cfg-actions {
            display: flex;
            flex-wrap: wrap;
            /* Allow buttons to wrap on small screens */
            gap: 6px;
            justify-content: flex-end;
        }

        .cfg-actions button {
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 6px;
            margin-left: 0 !important;
            /* Override inline style */
        }

        /* toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 12px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            box-shadow: 0 8px 24px rgba(2, 6, 23, 0.12);
            opacity: 0;
            transform: translateY(-10px) scale(.98);
            transition: all .22s ease;
            z-index: 60;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .toast.ok {
            background: #16a34a;
        }

        /* green */
        .toast.err {
            background: #dc2626;
        }

        /* red */

        /* progress color states */
        #progress.ok {
            background: #16a34a;
        }

        #progress.err {
            background: #dc2626;
        }

        #progress.loading {
            background: linear-gradient(90deg, rgba(79, 70, 229, 0.95), rgba(99, 102, 241, 0.95));
            animation: prog 1.3s linear infinite;
        }

        @keyframes prog {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        /* Footer style */
        footer.app-footer {
            background: var(--card);
            border-top: 1px solid #e6edf3;
            padding: 10px 16px;
            flex-shrink: 0;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            font-size: 11px;
            color: var(--muted);
            width: 100%;
        }


        /* responsive */
        @media (max-width: 900px) {
            .layout {
                padding: 0 8px;
                margin-top: 12px;
            }

            /* Topbar adjustments for mobile */
            .topbar {
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
                padding: 10px 8px;
            }

            .topbar .brand {
                flex-basis: 100%;
                justify-content: center;
                margin-bottom: 8px;
            }

            .topnav {
                order: 3;
                /* Move to the bottom row */
                flex-basis: 100%;
                justify-content: flex-start;
                /* Align left for scroll */
                overflow-x: auto;
                padding: 0;
            }

            .topnav button {
                font-size: 13px;
                padding: 7px 10px;
            }

            #filter-input {
                order: 2;
                /* Move below brand */
                max-width: none !important;
                flex: 1 !important;
                margin: 0;
            }

            .topbar>div:last-child {
                order: 4;
                /* Move file input/load button down */
                flex-basis: 100%;
                justify-content: center;
            }

            #map-container {
                height: 50vh;
                min-height: 300px;
            }

            .cfg-actions button {
                margin-left: 0 !important;
                flex-basis: 45%;
                /* Make buttons take half width */
            }
        }
    </style>
</head>

<body>

    <header class="app-header">
        <div class="topbar">
            <div class="brand">
                <svg width="34" height="34" viewBox="0 0 24 24" fill="none">
                    <rect width="24" height="24" rx="6" fill="#eef2ff" />
                    <path d="M7 12h10M7 8h10M7 16h10" stroke="#4f46e5" stroke-width="1.6" stroke-linecap="round" />
                </svg>
                <h1>Vg Events Viewer</h1>
            </div>

            <nav class="topnav" aria-label="Main navigation">
                <button id="nav-events" class="active" onclick="showSection('events')">Events</button>
                <button id="nav-map" onclick="showSection('map')">Map</button>
                <button id="nav-route" onclick="openRoute('Route.html')">Route</button>
                <button id="nav-best" onclick="showSection('best')">Best</button>
                <button id="nav-routeplan" onclick="openRoute('RoutePlan.html')">Route Plan</button>
            </nav>

            <input id="filter-input" placeholder="Rechercher titre, adresse ou ville..."
                style="flex: 1; max-width: 300px; padding:8px;border-radius:8px;border:1px solid #e6edf3"
                oninput="applyFilter()">

            <div style="display:flex;align-items:center;gap:12px;">
                <label style="font-size:12px;color:var(--muted);">
                    <input id="json-file-input" type="file" multiple accept=".json" style="display:none">
                    <button class="btn" onclick="document.getElementById('json-file-input').click()"
                        style="background:var(--indigo); color:white; border:none; border-radius:8px; padding:8px 10px;">Load
                        files</button>
                </label>
            </div>
        </div>

        <div id="progress-wrap" aria-hidden="true">
            <div id="progress"></div>
        </div>
    </header>

    <div class="layout">

        <div class="card">
            <section id="section-events">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
                    <div style="display:flex;gap:12px;align-items:center;">
                        <h2 style="margin:0;font-size:18px;font-weight:700" id="events-header">Événements</h2>
                    </div>
                    <div></div>
                </div>

                <div class="month-tabs" id="month-tabs" aria-label="Months"></div>

                <div id="month-content"></div>
                <p id="no-events" style="color:var(--muted); display:none;">Aucun événement trouvé.</p>
            </section>

            <section id="section-map" class="hidden" aria-hidden="true">
                <h3 style="margin-top:0">Carte des événements</h3>
                <div id="map-container">
                </div>
            </section>

            <section id="section-best" class="hidden" aria-hidden="true">
                <h3 style="margin-top:0">My Best Events</h3>
                <div id="best-events-list">
                </div>
                <p id="no-best-events" style="color:var(--muted); display:none; margin-top:12px;">No events saved to
                    Best
                    list yet.</p>
            </section>

        </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <footer class="app-footer">
        <div class="footer-content">
            <div id="footer-status-all" style="flex:1;">Initializing...</div>

            <button id="toggle-config-btn" onclick="toggleConfig()"
                style="background:var(--indigo);color:white;border:none;padding:6px 10px;border-radius:6px;font-size:12px;font-weight:600;margin-left:10px; flex-shrink: 0;">
                Config
            </button>
        </div>

        <section id="section-config" class="hidden" aria-hidden="true"
            style="max-width:1200px; margin:0 auto; padding-top:10px; border-top:1px solid #e6edf3; width:100%;">
            <h3 style="margin-top:0; font-size:16px;">Source Configuration</h3>
            <form id="source-form" style="display:grid;grid-template-columns:1fr 1fr auto;gap:10px;margin-top:12px;"
                onsubmit="return saveSource(event)">
                <input id="src-name" placeholder="Name e.g. Vg" required
                    style="padding:8px;border-radius:8px;border:1px solid #e6edf3" />
                <input id="src-url" placeholder="https://jsonhosting.com/api/json/..." required
                    style="padding:8px;border-radius:8px;border:1px solid #e6edf3" />
                <div style="display:flex;gap:8px; flex-shrink:0;">
                    <button type="submit"
                        style="background:var(--indigo);color:white;border:none;padding:8px 12px;border-radius:8px">Save</button>
                    <button type="button" onclick="resetForm()"
                        style="background:white;border:1px solid #e6edf3;padding:8px 12px;border-radius:8px">Reset</button>
                </div>
            </form>

            <div id="config-list" style="margin-top:12px;display:flex;flex-direction:column;gap:8px"></div>
        </section>
    </footer>

    <script>
        /* --- Config --- */
        const PROXY = 'https://api.codetabs.com/v1/proxy/?quest=';
        const STORAGE_KEY = 'eventsviewer_sources_v3';
        const BEST_KEY = 'eventsviewer_best_v1';
        const MONTH_ABBR = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
        const DAY_MAP = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        const DAY_COLORS = {
            'Samedi': '#7DF9FF', // Light Cyan
            'Dimanche': '#FFFAA0' // Light Yellow
        };
        const OTHER_DAY_COLOR = '#FAA0A0'; // Light Red
        const TAB_COLORS = ['#4f46e5', '#2563eb', '#16a34a', '#0ea5a4', '#06b6d4', '#db2777', '#f59e0b', '#7c3aed', '#10b981', '#ef4444', '#0ea5a4', '#f97316'];
        const START_ADDRESS = "5 rue victor considérant 75014 paris"; // Default origin address for maps
        const NOMINATIM_URL = 'https://nominatim.openstreetmap.org/search?format=json&limit=1';

        /* --- State --- */
        let activeSource = null;
        let activeFilterQuery = '';

        // Global state for source data and status
        const sourceCounts = {};
        let lastUpdate = 'N/A';
        let bestEventsState = loadBestEvents(); // Load 'Best' state on start

        // Map State
        let mapInstance = null;
        let mapLibsLoaded = false;
        let mapMarkers = [];
        let geocodingCache = {}; // Cache for lat/lon lookup
        let currentMonthTab = null; // To track the currently selected month tab


        /* --- Helpers --- */
        const $ = id => document.getElementById(id);
        const safeId = s => String(s).replace(/[^a-z0-9]/gi, '_');

        function showToast(message, status = 'ok', ms = 2200) {
            const t = $('toast');
            t.textContent = message;
            t.className = 'toast show ' + (status === 'err' ? 'err' : 'ok');
            t.setAttribute('aria-label', message);
            clearTimeout(t._h);
            t._h = setTimeout(() => t.className = 'toast', ms);
        }

        function updateFooterStatus() {
            const parts = Object.entries(sourceCounts)
                .filter(([name, details]) =>
                    details && (details.count > 0 || name === activeSource)
                )
                .map(([name, details]) =>
                    `${name} (${details.count})`
                );

            const lastUpdateDisplay = lastUpdate === 'N/A' ? 'N/A' : new Date(lastUpdate).toLocaleString('fr-FR');

            let footerContent = parts.join(' | ');

            if (footerContent) {
                footerContent += ' | ';
            } else {
                footerContent = 'No data loaded. | ';
            }

            footerContent += `Last update : ${lastUpdateDisplay}`;

            $('footer-status-all').textContent = footerContent;
        }

        function updateEventsHeader() {
            const header = $('events-header');
            if (activeSource) {
                const count = sourceCounts[activeSource]?.count || 0;
                header.textContent = `Événements - ${activeSource} (${count})`;
            } else {
                header.textContent = `Événements`;
            }
        }


        function getFrenchDay(date) {
            if (!date) return '';
            return DAY_MAP[date.getDay()];
        }

        function getDirectionsUrl(eventAddress) {
            const origin = encodeURIComponent(START_ADDRESS);
            const destination = encodeURIComponent(eventAddress);
            // FIX: Corrected to standard Google Maps Directions URL
            return `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}`;
        }

        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(query, 'gi');
            return text.replace(regex, match => `<mark style="background-color: #ffffe0; padding: 0 2px;">${match}</mark>`);
        }

        /* --- Progress bar --- */
        const progressEl = (() => $('progress'))();
        function progressStart() {
            progressEl.className = 'loading';
            progressEl.style.width = '6%';
            setTimeout(() => progressEl.style.width = '35%', 80);
        }
        function progressSetOk() {
            progressEl.className = 'ok';
            progressEl.style.width = '100%';
            setTimeout(() => { progressEl.style.width = '0%'; progressEl.className = ''; }, 700);
        }
        function progressSetErr() {
            progressEl.className = 'err';
            progressEl.style.width = '100%';
            setTimeout(() => { progressEl.style.width = '0%'; progressEl.className = ''; }, 1200);
        }

        /* --- Date parsing & grouping --- */
        function parseEventDate(str) {
            if (!str) return null;

            const match = str.match(/(?:[a-zA-ZÀ-ÿ]+\s+)*(\d{1,2})\s+([a-zéûäàîôA-Z]+)\s+(\d{4})/i);

            if (!match) return null;

            const d = +match[1];
            const monthStr = match[2].toLowerCase();
            const y = +match[3];

            const map = {
                janvier: 0, février: 1, fevrier: 1, mars: 2, avril: 3, mai: 4, juin: 5,
                juillet: 6, août: 7, aout: 7, septembre: 8, octobre: 9, novembre: 10, décembre: 11, decembre: 11,
                january: 0, february: 1, march: 2, april: 3, may: 4, june: 5, july: 6, august: 7,
                september: 8, october: 9, november: 10, december: 11
            };

            const mo = map[monthStr];

            return typeof mo === 'number' ? new Date(y, mo, d) : null;
        }

        function formatMonthKey(d) { return `${MONTH_ABBR[d.getMonth()]} ${d.getFullYear()}`; }

        function extractEvents(node, out) {
            if (!node) return;

            const eventKeys = ["Titre", "Ville", "Adresse", "Exposants", "ManifDate", "ManifLink"];
            const requiredKeys = ["Titre", "Adresse", "ManifDate"];

            const normalizeEvent = (item) => {
                const event = {};
                eventKeys.forEach(k => {
                    if (item.hasOwnProperty(k)) event[k] = item[k];
                });
                return event;
            };

            if (Array.isArray(node)) {
                const validEvents = node.filter(item =>
                    typeof item === 'object' && requiredKeys.every(k => item.hasOwnProperty(k))
                ).map(normalizeEvent);

                if (validEvents.length > 0) {
                    out.push(...validEvents);
                } else {
                    node.forEach(v => extractEvents(v, out));
                }
            }
            else if (typeof node === 'object') {
                if (requiredKeys.every(k => node.hasOwnProperty(k))) {
                    out.push(normalizeEvent(node));
                }

                Object.values(node).forEach(v => extractEvents(v, out));
            }
        }

        function groupEvents(evts) {
            const g = {};
            for (const e of evts) {
                const d = parseEventDate(e.ManifDate);
                if (!d) continue;
                const m = formatMonthKey(d);
                g[m] ??= {};
                g[m][e.ManifDate] ??= [];
                g[m][e.ManifDate].push(e);
            }
            return g;
        }
        function sortGrouped(g) {
            const out = {};
            Object.keys(g).sort((a, b) => {
                const [ma, ya] = a.split(' '), [mb, yb] = b.split(' ');
                const ia = MONTH_ABBR.indexOf(ma), ib = MONTH_ABBR.indexOf(mb);
                return (+ya - +yb) || ia - ib;
            }).forEach(m => {
                out[m] = {};
                Object.keys(g[m]).sort((a, b) => parseEventDate(a) - parseEventDate(b))
                    .forEach(d => out[m][d] = [...g[m][d]]);
            });
            return out;
        }

        function toggleDayCollapse(currentDayCard, monthPanelId) {
            const currentContent = currentDayCard.querySelector('.day-content');
            const isOpen = currentContent.style.display === 'block';

            const monthPanel = $(monthPanelId);
            if (monthPanel) {
                // Collapse all day cards in this panel first
                monthPanel.querySelectorAll('.day-card').forEach(dayCard => {
                    const content = dayCard.querySelector('.day-content');
                    if (content) {
                        content.style.display = 'none';
                    }
                });
            }

            // Open the clicked one if it was closed
            if (!isOpen) {
                currentContent.style.display = 'block';
            }
        }

        /* --- Best Events Logic --- */
        function loadBestEvents() {
            try {
                return JSON.parse(localStorage.getItem(BEST_KEY) || '[]');
            } catch {
                return [];
            }
        }

        function saveBestEvents() {
            localStorage.setItem(BEST_KEY, JSON.stringify(bestEventsState));
            // Only re-render the best section if it is currently visible (SILENTLY FILL)
            if ($('section-best') && !$('section-best').classList.contains('hidden')) {
                renderBestSection();
            }
        }

        /**
         * Generates a unique ID for an event based on its core properties.
         * @param {object} event 
         * @returns {string}
         */
        function getEventId(event) {
            // Concatenate unique properties to form a simple ID for comparison
            return `${event.Titre || ''}|${event.Adresse || ''}|${event.ManifDate || ''}`;
        }

        function isEventInBest(event) {
            const id = getEventId(event);
            return bestEventsState.some(e => getEventId(e) === id);
        }

        function toggleBestEvent(event) {
            const id = getEventId(event);
            const index = bestEventsState.findIndex(e => getEventId(e) === id);

            if (index > -1) {
                // Remove
                bestEventsState.splice(index, 1);
                showToast('Event removed from Best', 'ok', 1500);
            } else {
                // Add
                bestEventsState.push(event);
                showToast('Event added to Best', 'ok', 1500);
            }
            saveBestEvents();

            // Re-render the current events view to update the button icon instantly
            if ($('section-events') && !$('section-events').classList.contains('hidden')) {
                applyFilter(); // This will re-render the event list with updated buttons
            }
        }

        /* --- Render functions --- */
        function renderSources() {
            const s = loadSources();
            const cfg = $('config-list'); cfg.innerHTML = '';

            if (Object.keys(s).length === 0) {
                s['Vg'] = 'https://jsonhosting.com/api/json/c3cdf9e5';
                s['Broc'] = 'https://jsonhosting.com/api/json/2ea29f9a';
                localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
            }

            Object.keys(s).forEach(name => {
                const url = s[name];

                // config row (used by all source management now)
                const row = document.createElement('div'); row.className = 'config-row';

                // Div to hold name and URL with Copy URL button
                const leftDiv = document.createElement('div'); leftDiv.style.fontSize = '13px';
                leftDiv.style.display = 'flex';
                leftDiv.style.alignItems = 'center';

                const nameUrlSpan = document.createElement('span');
                nameUrlSpan.textContent = name + ' — ' + url;
                leftDiv.appendChild(nameUrlSpan);

                // Copy URL button
                const copyUrlBtn = document.createElement('button');
                copyUrlBtn.textContent = '';
                copyUrlBtn.title = 'Copy URL';
                copyUrlBtn.style.padding = '0 6px';
                copyUrlBtn.style.marginLeft = '8px';
                copyUrlBtn.style.background = 'transparent';
                copyUrlBtn.style.border = 'none';
                copyUrlBtn.style.cursor = 'pointer';
                copyUrlBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#4f46e5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1"></rect></svg>`;
                copyUrlBtn.onclick = () => copyToClipboard(url);

                if (!url.startsWith('local://')) {
                    leftDiv.appendChild(copyUrlBtn);
                }

                const right = document.createElement('div'); right.className = 'cfg-actions';

                // NEW: View button - this now handles source selection logic
                const vBtn = document.createElement('button'); vBtn.textContent = 'View'; vBtn.onclick = () => selectSource(name);

                const eBtn = document.createElement('button'); eBtn.textContent = 'Edit'; eBtn.onclick = () => editSource(name);
                const dBtn = document.createElement('button'); dBtn.textContent = 'Delete'; dBtn.onclick = () => removeSource(name);

                // NEW: Download button
                const dlBtn = document.createElement('button'); dlBtn.textContent = 'Download';
                if (url.startsWith('http')) {
                    // Assuming the raw URL is the one without the proxy for downloading
                    dlBtn.onclick = () => downloadSource(name, url);
                } else {
                    dlBtn.disabled = true;
                    dlBtn.style.opacity = 0.5;
                    dlBtn.title = 'Only remote sources can be downloaded.';
                }

                [vBtn, eBtn, dBtn, dlBtn].forEach(b => {
                    b.style.border = '1px solid #e6edf3';
                    b.style.borderRadius = '6px';
                    b.style.background = 'white';
                    b.style.cursor = b.disabled ? 'default' : 'pointer';
                });

                // Highlight the active source's button
                if (activeSource === name) {
                    // FIX: Must wrap 'var(...)' in quotes when assigning to style property in JS
                    vBtn.style.background = 'var(--accent)';
                    vBtn.style.color = 'var(--indigo)';
                    vBtn.style.fontWeight = 600;
                }


                right.appendChild(vBtn);
                right.appendChild(eBtn);
                right.appendChild(dBtn);
                right.appendChild(dlBtn);

                row.appendChild(leftDiv);
                row.appendChild(right);
                cfg.appendChild(row);
            });
        }

        function renderTabsForGrouped(g) {
            const tabs = $('month-tabs'); tabs.innerHTML = '';
            const months = Object.keys(g);
            if (!months.length) { $('no-events').style.display = 'block'; return; } else $('no-events').style.display = 'none';

            months.forEach((m, i) => {
                const btn = document.createElement('div');
                btn.className = 'month-tab';
                btn.style.background = TAB_COLORS[i % TAB_COLORS.length];
                btn.textContent = m;
                btn.onclick = () => openMonth(m);
                btn.dataset.month = m;
                tabs.appendChild(btn);
            });
        }

        /**
         * Renders grouped events into a container. This is used for both 'Events' and 'Best' sections.
         * @param {Object} g - The grouped and sorted events.
         * @param {string} containerId - The ID of the container element (e.g., 'month-content', 'best-events-list').
         * @param {string} prefixId - Prefix for month and day panel IDs (e.g., 'panel_', 'best_panel_').
         * @param {boolean} showMonthHeader - If true, displays the month name before event days.
         */
        function renderGroupedEvents(g, containerId, prefixId, showMonthHeader = false) {
            const container = $(containerId); container.innerHTML = '';

            Object.keys(g).forEach(month => {
                const monthId = prefixId + safeId(month);

                // Add month header for the 'Best' section where all months are displayed
                if (showMonthHeader) {
                    const monthHeader = document.createElement('h4');
                    monthHeader.textContent = month;
                    monthHeader.style.cssText = 'margin:16px 0 8px 0; font-size:16px; font-weight:700; color:var(--indigo); border-bottom:1px solid #eef2f8; padding-bottom:4px;';
                    container.appendChild(monthHeader);
                }

                const panel = document.createElement('div'); panel.id = monthId;
                panel.dataset.monthName = month; // Used by openMonth for 'Events' section

                Object.keys(g[month]).sort((a, b) => parseEventDate(a) - parseEventDate(b)).forEach(day => {
                    const dateObj = parseEventDate(day);
                    const frenchDay = getFrenchDay(dateObj);
                    const displayDate = day.replace(new RegExp(`^${frenchDay}\\s+`, 'i'), '');

                    const color = DAY_COLORS[frenchDay] || OTHER_DAY_COLOR;

                    const dayDiv = document.createElement('div'); dayDiv.className = 'day-card';
                    const head = document.createElement('div'); head.className = 'day-head';
                    head.style.background = color;

                    head.innerHTML = `<div><strong>${frenchDay} ${displayDate}</strong> <span style="color:#1f2937;font-size:13px;font-weight:500">(${g[month][day].length})</span></div>`;

                    head.onclick = () => toggleDayCollapse(dayDiv, monthId);

                    const content = document.createElement('div'); content.className = 'day-content';
                    content.style.display = 'none'; // Always start collapsed

                    // add events
                    g[month][day].forEach(ev => {

                        const directionsAddress = (ev.Adresse || '').trim() + (ev.Ville ? ', ' + ev.Ville : '');
                        const directionsUrl = getDirectionsUrl(directionsAddress);

                        const metaAddress = (ev.Adresse || '').trim().replace(/,\s*$/g, '');

                        const evRow = document.createElement('div'); evRow.className = 'event-row';

                        // 0. Best Button (Add/Remove)
                        const isBest = isEventInBest(ev);
                        const bestBtn = document.createElement('button'); bestBtn.className = 'best-toggle-btn';
                        bestBtn.title = isBest ? 'Remove from Best' : 'Add to Best';
                        bestBtn.style.flexShrink = 0;
                        bestBtn.style.marginRight = '4px';

                        // Use Plus/Minus icons
                        bestBtn.innerHTML = isBest
                            ? `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#dc2626" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>` // Minus/Red
                            : `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#16a34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`; // Plus/Green

                        bestBtn.onclick = () => toggleBestEvent(ev);


                        // 1. Copy Address button
                        const clipBtn = document.createElement('button'); clipBtn.className = 'copy-addr-btn'; clipBtn.title = 'Copy address';
                        clipBtn.style.flexShrink = 0;
                        clipBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#4f46e5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1"></rect></svg>`;
                        clipBtn.onclick = () => copyToClipboard(metaAddress);

                        // 2. Copy Event Link button
                        const linkBtn = document.createElement('button'); linkBtn.className = 'copy-link-btn'; linkBtn.title = 'Copy event link';
                        linkBtn.style.flexShrink = 0;
                        linkBtn.style.marginLeft = '4px';
                        linkBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#4f46e5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.74 1.74"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>`;
                        linkBtn.onclick = () => copyToClipboard(ev.ManifLink || window.location.href);

                        // 3. Event Body (Title + Meta)
                        const body = document.createElement('div'); body.style.flex = '1';

                        // Title Format: Titre (Ville) 
                        const newTitleText = `${ev.Titre || 'Sans titre'} ${ev.Ville ? `(${ev.Ville})` : ''}`.trim();

                        const title = document.createElement('a');
                        title.href = ev.ManifLink || '#';
                        title.target = '_blank';
                        title.className = 'title';
                        title.innerHTML = highlightText(newTitleText, activeFilterQuery);

                        // Exposants logic and formatting
                        const exposantCount = parseInt(ev.Exposants) || 0;
                        let exposantDisplay = '';
                        let exposantColor = 'inherit';

                        if (exposantCount > 0) {
                            if (exposantCount >= 300) {
                                exposantColor = '#dc2626'; // Red
                            } else if (exposantCount >= 101) {
                                exposantColor = '#f59e0b'; // Orange
                            }
                            exposantDisplay = `<span style="font-weight:700; color:${exposantColor};">${exposantCount}</span> | `;
                        }

                        // Meta Format: <Exposant Count> | Adresse
                        const metaText = `${exposantDisplay}${metaAddress}`;

                        const meta = document.createElement('div');
                        meta.className = 'meta';
                        meta.innerHTML = highlightText(metaText, activeFilterQuery);

                        body.appendChild(title);
                        body.appendChild(meta);

                        // 4. Directions icon button
                        const mapBtn = document.createElement('button'); mapBtn.className = 'map-btn'; mapBtn.title = 'Itinéraire Google Maps';
                        mapBtn.style.flexShrink = 0;
                        mapBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4f46e5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg>`;
                        mapBtn.onclick = () => window.open(directionsUrl, '_blank');

                        evRow.appendChild(bestBtn);
                        evRow.appendChild(clipBtn);
                        evRow.appendChild(linkBtn);
                        evRow.appendChild(body);
                        evRow.appendChild(mapBtn);
                        content.appendChild(evRow);
                    });

                    dayDiv.appendChild(head); dayDiv.appendChild(content);
                    panel.appendChild(dayDiv);
                });

                container.appendChild(panel);
            });

        }

        function updateEventUI(r, g, name) {
            renderTabsForGrouped(g);
            renderGroupedEvents(g, 'month-content', 'panel_', false); // Use new generic renderer
            updateEventsHeader();
            renderSources(); // Re-render source list in config to update active button

            // Open the first month by default if not already set, or re-open the current one
            const months = Object.keys(g);
            if (months.length > 0) {
                const monthToOpen = currentMonthTab && months.includes(currentMonthTab) ? currentMonthTab : months[0];
                openMonth(monthToOpen);
            }

            // Clear map on data change
            if (mapInstance) {
                mapMarkers = [];
                mapInstance.eachLayer(layer => {
                    if (layer instanceof L.Marker) {
                        mapInstance.removeLayer(layer);
                    }
                });
            }
        }

        function renderBestSection() {
            const container = $('best-events-list');
            const noEvents = $('no-best-events');
            const bestEvents = loadBestEvents();

            if (bestEvents.length === 0) {
                container.innerHTML = '';
                noEvents.style.display = 'block';
                return;
            }

            noEvents.style.display = 'none';

            // Group and sort best events by date
            const grouped = sortGrouped(groupEvents(bestEvents));

            // Use the same renderer as the events section, but show month headers
            renderGroupedEvents(grouped, 'best-events-list', 'best_panel_', true);
        }


        function openMonth(month) {
            currentMonthTab = month;

            document.querySelectorAll('.month-tab').forEach(tb => tb.classList.remove('active'));
            const tab = [...document.querySelectorAll('.month-tab')].find(x => x.textContent === month);
            if (tab) tab.classList.add('active');

            // Find all month panels in the events section
            document.querySelectorAll('#month-content > div').forEach(el => {
                el.style.display = 'none';
            });

            const panel = document.querySelector(`#month-content > div[data-month-name="${month}"]`);

            if (panel) {
                panel.style.display = 'block';
                // Automatically open the first day of the newly opened month panel
                const firstDayCard = panel.querySelector('.day-card');
                if (firstDayCard) {
                    const firstDayContent = firstDayCard.querySelector('.day-content');
                    if (firstDayContent) {
                        firstDayContent.style.display = 'block';
                    }
                }
            }
        }

        /* --- Sources storage CRUD & Download --- */
        function loadSources() {
            try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch { return {}; }
        }
        function saveSources(obj) { localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); renderSources(); }

        function saveSource(e) {
            e.preventDefault();
            const name = $('src-name').value.trim();
            const url = $('src-url').value.trim();
            if (!name || !url) return false;
            const s = loadSources(); s[name] = url; saveSources(s);
            $('src-name').value = ''; $('src-url').value = '';
            showToast('Source saved', 'ok');
            selectSource(name);
            return false;
        }
        function resetForm() { $('src-name').value = ''; $('src-url').value = ''; }
        function editSource(name) {
            const s = loadSources();
            if (!s[name]) return showToast('Source not found', 'err');
            $('src-name').value = name; $('src-url').value = s[name];
        }
        function removeSource(name) {
            const s = loadSources(); if (!s[name]) return;
            delete s[name]; saveSources(s);
            delete sourceCounts[name];
            updateFooterStatus();
            showToast('Source removed', 'ok');
            if (activeSource === name) {
                const remainingSources = Object.keys(loadSources());
                if (remainingSources.length > 0) {
                    selectSource(remainingSources[0]);
                } else {
                    activeSource = null;
                    updateEventUI([], {}, null);
                }
            }
        }

        /**
         * Downloads the raw JSON from the source URL.
         * @param {string} name - Source name.
         * @param {string} url - Source URL.
         */
        async function downloadSource(name, url) {
            progressStart();

            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error('HTTP ' + res.status);

                const blob = await res.blob();

                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `${name}_events_${new Date().toISOString().substring(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);

                progressSetOk();
                showToast(`Successfully downloaded ${name}.json`, 'ok', 3000);

            } catch (err) {
                progressSetErr();
                showToast(`Download failed for ${name}. Check URL or CORS settings.`, 'err', 5000);
                console.error(`Download failed for ${name}:`, err);
            }
        }


        /* --- Core Fetching Logic --- */
        async function fetchSource(name, url, isInitialLoad = false) {
            const fetchUrl = url.startsWith('http') ? PROXY + encodeURIComponent(url) : url;

            if (isInitialLoad) progressStart();

            console.log(`[DEBUG: ${name}] Starting fetch from: ${fetchUrl}`);

            try {
                const res = await fetch(fetchUrl);
                if (!res.ok) throw new Error('HTTP ' + res.status);

                const text = await res.text();
                const json = JSON.parse(text);

                const r = [];
                extractEvents(json, r);
                const g = sortGrouped(groupEvents(r));

                const now = new Date().toISOString();
                lastUpdate = now;

                // Store raw event data with coordinates pre-populated later by renderMap
                sourceCounts[name] = { count: r.length, loadedAt: now, status: 'ok', rawEvents: r, grouped: g, mappedEvents: [] };

                if (activeSource === name) {
                    updateEventUI(r, g, name);
                }

                updateFooterStatus();
                if (isInitialLoad) progressSetOk();

                if (r.length > 0 && activeSource === name) {
                    showToast(`Events data loaded. Total: ${r.length} events.`, 'ok', 3000);
                }

            } catch (err) {
                sourceCounts[name] = { count: 0, loadedAt: new Date().toISOString(), status: 'error', rawEvents: [], grouped: {} };
                const errorMessage = `Load error for ${name} (Proxy/CORS/JSON parse failure).`;

                if (activeSource === name) {
                    updateEventUI([], {}, name);
                }

                updateFooterStatus();
                if (isInitialLoad) progressSetErr();
                if (activeSource === name) showToast(errorMessage, 'err');
                console.error(`Fetch failed for ${name}:`, err);
            }
        }

        async function selectSource(name) {
            const all = loadSources();
            if (!all[name]) return showToast('Source not found', 'err');

            // If we are already on this source and data is loaded, just update UI
            if (activeSource === name && sourceCounts[name]?.status === 'ok') {
                updateEventUI(sourceCounts[name].rawEvents, sourceCounts[name].grouped, name);
                if (mapInstance) renderMap(sourceCounts[name].rawEvents);
                return;
            }

            activeSource = name;
            renderSources(); // Re-render config list to highlight active source
            updateEventsHeader();

            $('filter-input').value = '';
            activeFilterQuery = '';

            const loadedData = sourceCounts[name];

            if (loadedData && loadedData.status === 'ok') {
                updateEventUI(loadedData.rawEvents, loadedData.grouped, name);
                if (mapInstance) renderMap(loadedData.rawEvents);
            } else if (all[name].startsWith('local://') && loadedData) {
                // Already loaded local file data, but maybe not rendered yet
                updateEventUI(loadedData.rawEvents, loadedData.grouped, name);
            } else {
                updateEventUI([], {}, name);
            }
            updateFooterStatus();

            if (all[name].startsWith('http')) {
                await fetchSource(name, all[name], true);
            }
        }

        /* --- Map Geocoding and Rendering --- */
        async function geocodeAddress(address) {
            if (geocodingCache[address]) return geocodingCache[address];

            try {
                const url = NOMINATIM_URL + '&q=' + encodeURIComponent(address);
                const res = await fetch(url);
                const json = await res.json();

                if (json && json.length > 0) {
                    const result = { lat: parseFloat(json[0].lat), lon: parseFloat(json[0].lon) };
                    geocodingCache[address] = result;
                    return result;
                }
            } catch (error) {
                console.error('Geocoding error:', error);
            }
            geocodingCache[address] = null;
            return null;
        }

        async function renderMap(events) {
            if (!mapInstance || !events) return;

            mapMarkers.forEach(m => mapInstance.removeLayer(m));
            mapMarkers = [];
            const mappedEvents = [];
            let bounds = null;

            for (const ev of events) {
                const fullAddress = `${ev.Adresse || ''}, ${ev.Ville || ''}, France`.trim();
                if (!fullAddress) continue;

                const coords = await geocodeAddress(fullAddress);

                if (coords) {
                    const titleText = `${ev.Titre || 'Sans titre'} (${ev.Ville || '?'})`;
                    const metaText = `${ev.Exposants || '?'} | ${ev.Adresse || '?'}`;

                    const popupContent = `
                        <div style="max-width:250px;">
                            <h4 style="font-weight:700; font-size:16px; margin:0;">${titleText}</h4>
                            <p style="font-size:12px; color:#666; margin:4px 0;">${ev.ManifDate}</p>
                            <p style="font-size:14px; margin:0 0 8px 0;">${metaText}</p>
                            <a href="${ev.ManifLink || '#'}" target="_blank" style="color:var(--indigo); font-size:13px; font-weight:600;">Voir l'événement</a>
                        </div>
                    `;

                    const marker = L.marker([coords.lat, coords.lon]).addTo(mapInstance)
                        .bindPopup(popupContent);

                    mapMarkers.push(marker);
                    mappedEvents.push(ev);

                    if (!bounds) bounds = L.latLngBounds([coords.lat, coords.lon], [coords.lat, coords.lon]);
                    else bounds.extend([coords.lat, coords.lon]);
                }
            }

            if (sourceCounts[activeSource]) {
                sourceCounts[activeSource].mappedEvents = mappedEvents;
            }

            if (bounds && mapMarkers.length > 0) {
                mapInstance.fitBounds(bounds, { padding: [50, 50] });
            } else {
                mapInstance.setView([46.603354, 1.888334], 6);
            }

            if (mappedEvents.length > 0) {
                showToast(`${mappedEvents.length} events were mapped successfully!`, 'ok', 4000);
            } else {
                showToast(`No events could be mapped for the selected source.`, 'err', 4000);
            }
        }

        /* --- Lazy Loading of Map Libraries --- */
        function loadMapLibs(callback) {
            if (mapLibsLoaded) {
                callback();
                return;
            }

            progressStart();

            // 1. Load Leaflet CSS
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
            link.integrity = 'sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=';
            link.crossOrigin = '';
            document.head.appendChild(link);

            // 2. Load Leaflet JS
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
            script.integrity = 'sha256-20n6n+A4GfJfeWjYwWkE/B5uK5l9L5kP9z8mO+3j/Qc=';
            script.crossOrigin = '';

            script.onload = () => {
                mapLibsLoaded = true;
                progressSetOk();
                showToast('Map library loaded.', 'ok', 1500);
                callback();
            };

            script.onerror = () => {
                progressSetErr();
                showToast('Failed to load map library.', 'err', 4000);
            }

            document.head.appendChild(script);
        }

        function initMap() {
            if (mapInstance) return; // Already initialized

            try {
                // Initialize map instance
                mapInstance = L.map('map-container').setView([46.603354, 1.888334], 6); // Default view: Center of France

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                }).addTo(mapInstance);

                // If a source is active, render its data immediately
                if (activeSource && sourceCounts[activeSource] && sourceCounts[activeSource].status === 'ok') {
                    renderMap(sourceCounts[activeSource].rawEvents);
                }

                // Fix map tile rendering issue in hidden containers by forcing an update
                setTimeout(() => mapInstance.invalidateSize(true), 100);

            } catch (e) {
                console.error("Map initialization failed. Leaflet might not be loaded.", e);
            }
        }


        /* --- Nav / Route / Config --- */
        function showSection(name) {
            // Main sections in the 'card'
            ['events', 'map', 'best'].forEach(s => {
                const el = document.getElementById('section-' + s);
                if (!el) return;
                if (s === name) {
                    el.classList.remove('hidden');
                    el.removeAttribute('aria-hidden');
                }
                else {
                    el.classList.add('hidden');
                    el.setAttribute('aria-hidden', 'true');
                }
            });

            // Hide config section in footer when switching main tabs
            const configSection = $('section-config');
            if (configSection) {
                configSection.classList.add('hidden');
                configSection.setAttribute('aria-hidden', 'true');
                $('toggle-config-btn').textContent = 'Config';
            }

            document.querySelectorAll('.topnav button').forEach(b => b.classList.remove('active'));
            const navBtn = document.getElementById('nav-' + name);
            if (navBtn) navBtn.classList.add('active');

            if (name === 'map' && !mapLibsLoaded) {
                loadMapLibs(initMap);
            } else if (name === 'map' && mapInstance) {
                setTimeout(() => {
                    mapInstance.invalidateSize(true);
                    if (activeSource && sourceCounts[activeSource] && sourceCounts[activeSource].status === 'ok' && mapMarkers.length > 0) {
                        const bounds = L.latLngBounds(mapMarkers.map(m => m.getLatLng()));
                        mapInstance.fitBounds(bounds, { padding: [50, 50] });
                    } else if (activeSource && sourceCounts[activeSource] && sourceCounts[activeSource].status === 'ok') {
                        renderMap(sourceCounts[activeSource].rawEvents);
                    }
                }, 100);
            } else if (name === 'best') {
                renderBestSection();
            }
        }

        function openRoute(filename) {
            window.open(filename, '_blank');
        }

        function toggleConfig() {
            const configSection = $('section-config');
            const btn = $('toggle-config-btn');
            const isHidden = configSection.classList.contains('hidden');

            if (isHidden) {
                configSection.classList.remove('hidden');
                configSection.removeAttribute('aria-hidden');
                btn.textContent = 'Close Config';
            } else {
                configSection.classList.add('hidden');
                configSection.setAttribute('aria-hidden', 'true');
                btn.textContent = 'Config';
            }
        }


        /* --- Local file handling (input) --- */
        function handleFiles(fileList) {
            if (!fileList || fileList.length === 0) return showToast('No files selected', 'err');
            const files = Array.from(fileList).filter(f => f.name.toLowerCase().endsWith('.json'));
            if (!files.length) {
                $('json-file-input').value = '';
                return showToast('No JSON files found', 'err');
            }

            progressStart();
            const sourceName = 'Local';

            const accum = [];
            let processed = 0;

            files.forEach(f => {
                const r = new FileReader();
                r.onload = e => {
                    try {
                        const js = JSON.parse(e.target.result);
                        extractEvents(js, accum);
                    } catch (ex) {
                        console.warn('invalid json', f.name, ex);
                        showToast(`Invalid JSON in ${f.name}`, 'err', 4000);
                    }
                    processed++;
                    if (processed === files.length) {

                        const s = loadSources();
                        s[sourceName] = 'local://loaded:' + files.length;
                        saveSources(s);

                        activeSource = sourceName;

                        const g = sortGrouped(groupEvents(accum));

                        const now = new Date().toISOString();
                        lastUpdate = now;

                        sourceCounts[sourceName] = { count: accum.length, loadedAt: now, status: 'ok', rawEvents: accum, grouped: g, mappedEvents: [] };

                        updateEventUI(accum, g, sourceName);
                        updateFooterStatus();
                        if (mapInstance) renderMap(accum);

                        progressSetOk();
                        showToast(`Local files loaded. Found ${accum.length} events.`, 'ok');
                    }
                };
                r.onerror = e => {
                    processed++;
                    console.error('File read error', f.name, e);
                    showToast(`File read error for ${f.name}`, 'err', 4000);
                    if (processed === files.length) {
                        progressSetErr();
                        updateFooterStatus();
                    }
                }
                r.readAsText(f);
            });
            $('json-file-input').value = '';
        }

        /* --- File input wiring --- */
        $('json-file-input').addEventListener('change', ev => {
            handleFiles(ev.target.files);
        });

        /* --- Clipboard --- */
        function copyToClipboard(txt) {
            navigator.clipboard.writeText(txt).then(() => {
                showToast('Copied to clipboard', 'ok');
            }).catch(err => {
                console.error('Could not copy text: ', err);
                const textarea = document.createElement('textarea');
                textarea.value = txt;
                document.body.appendChild(textarea);
                textarea.focus();
                textarea.select();
                try {
                    document.execCommand('copy');
                    showToast('Copied to clipboard (fallback)', 'ok');
                } catch (e) {
                    showToast('Copy failed', 'err');
                }
                document.body.removeChild(textarea);
            });
        }

        /* --- Filter --- */
        function applyFilter() {
            const q = $('filter-input').value.trim().toLowerCase();
            activeFilterQuery = q;

            const loadedData = sourceCounts[activeSource];
            if (!loadedData || loadedData.status !== 'ok') {
                renderTabsForGrouped({});
                renderGroupedEvents({}, 'month-content', 'panel_', false);
                return;
            }

            const rawEventsToFilter = loadedData.rawEvents;

            const filtered = rawEventsToFilter.filter(e =>
                (e.Titre || '').toLowerCase().includes(q) ||
                (e.Adresse || '').toLowerCase().includes(q) ||
                (e.Ville || '').toLowerCase().includes(q)
            );

            const g = sortGrouped(groupEvents(filtered));

            renderTabsForGrouped(g);
            renderGroupedEvents(g, 'month-content', 'panel_', false);

            // Re-select the month to open the corresponding tab/panel
            const months = Object.keys(g);
            if (months.length > 0) {
                const monthToOpen = currentMonthTab && months.includes(currentMonthTab) ? currentMonthTab : months[0];
                openMonth(monthToOpen);
            }
        }

        /* --- Init --- */
        function init() {
            renderSources();
            const s = loadSources();
            const sourceNames = Object.keys(s);

            // 1. Initialize sourceCounts structure and start fetching all remote sources
            sourceNames.forEach(name => {
                sourceCounts[name] = { count: 0, loadedAt: new Date().toISOString(), status: 'idle', rawEvents: [], grouped: {}, mappedEvents: [] };
                if (!s[name].startsWith('local://')) {
                    // Fetch all sources in the background, but only display the first one initially
                    const isFirstSource = name === sourceNames[0];
                    fetchSource(name, s[name], isFirstSource);
                }
            });

            // 2. Select the first source to display its events immediately (will wait for fetch if remote)
            if (sourceNames.length > 0) {
                selectSource(sourceNames[0]);
            } else {
                updateEventsHeader();
                updateEventUI([], {}, null);
            }

            // Load initial state for the best events, even if the section is not visible
            bestEventsState = loadBestEvents();

            updateFooterStatus();
        }
        init();

    </script>
</body>

</html>